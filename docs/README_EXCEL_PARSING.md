# Excel 解析与切割逻辑说明

本文档详细说明了 ActivityRuleEditor 项目中 Excel 文件的结构和解析逻辑，用于将 Excel 数据转换为 JSON 格式的页面数据。

## 目录

- [Excel 结构概览](#excel-结构概览)
- [解析流程](#解析流程)
- [标记说明](#标记说明)
- [数据结构](#数据结构)
- [常见问题](#常见问题)

---

## Excel 结构概览

Excel 文件采用**分区分段**的结构设计，通过特定标记来划分不同的内容区域。

### 整体结构层次

```
Excel 工作表
├── REGION（页面/区域） - 纵向分割
│   ├── TITLE（段落区块） - 横向分割
│   │   ├── RULES（规则部分）
│   │   └── RINK（奖励部分）
│   ├── TITLE（段落区块）
│   │   └── ...
│   └── ...
└── REGION（另一个页面/区域）
    └── ...
```

---

## 解析流程

### 1. 纵向分割（按列分割页面）

**目标**：将 Excel 按列分割成多个独立的页面（Page）

#### 标记：`REGION-`

- **位置**：第一行
- **格式**：`REGION-<区域代码>`
  - 示例：`REGION-TW`、`REGION-VN`
- **特点**：
  - `REGION-` 所在的单元格处于**合并状态**
  - 合并范围内的所有单元格内容都是重复的
  - 从 `REGION-` 标记所在列开始，到**空列**为止，这是一个完整的页面

#### 解析逻辑

```python
# 伪代码
for 每一行 in Excel:
    for 每一列 in 当前行:
        if 单元格内容以 "REGION-" 开头:
            # 确定合并单元格的列范围
            起始列 = 合并范围.min_col
            结束列 = 合并范围.max_col
            # 创建一个页面区域
            页面 = {
                "code": "REGION-" 后面的文本,
                "col_start": 起始列,
                "col_end": 结束列
            }
```

**注意事项**：
- 需要处理合并单元格，避免重复识别同一个 `REGION-` 标记
- 按列从左到右排序，确保页面顺序正确

---

### 2. 横向分割（按行分割段落区块）

**目标**：在每个页面内，按行分割成多个段落区块

#### 标记：`TITLE-`

- **位置**：页面区域内的任意行的第一列
- **格式**：`TITLE-<段落标题>`
  - 示例：`TITLE-活动规则`、`TITLE-奖励说明`
- **范围**：从 `TITLE-` 行开始，到**下一个 `TITLE-` 行**或**空行**为止

#### 解析逻辑

```python
# 伪代码
for 每个页面 in 页面列表:
    起始行 = 页面.row + 1  # REGION- 的下一行

    # 扫描所有 TITLE- 标记
    for 行号 in range(起始行, Excel最大行):
        if 第一列内容以 "TITLE-" 开头:
            段落标题 = "TITLE-" 后面的文本
            段落起始行 = 行号 + 1
            段落结束行 = 下一个TITLE行号 - 1 或 Excel最大行

            # 解析段落区块内容
            parse_section_block(段落起始行, 段落结束行)
```

---

### 3. 段落区块内容解析

每个段落区块内包含两种类型的内容：**规则部分（RULES-）** 和 **奖励部分（RINK-）**

---

#### A. 规则部分（RULES-）

**目标**：提取文本规则内容

##### 标记：`RULES-`

- **位置**：段落区块内任意行的第一列
- **格式**：
  - `RULES-<小标题>` - 带小标题的规则
  - `RULES-` - 无小标题的规则
- **内容特点**：
  - 除了第一列的标记外，**后面的列可能是合并的（重复的）**
  - 每行可能包含多列
  - **需要去重**：同一行的多个列如果内容相同，只保留一次

##### 列结构

```
| 列1(标记列) | 列2(内容)    | 列3(内容)    | 列4(内容)    | ...
|-------------|--------------|--------------|--------------|
| RULES-规则  | 一、活动时间 | 一、活动时间 | 一、活动时间 | <- 合并单元格导致重复
|             | 8.27 00:00   | 8.27 00:00   | 8.27 00:00   | <- 合并单元格导致重复
|             | 二、活动玩法 | 二、活动玩法 | 二、活动玩法 | <- 合并单元格导致重复
```

##### 解析逻辑

```python
# 伪代码
def collect_rules_content(起始行, 标题):
    行内容列表 = []
    已见行内容集合 = set()  # 用于跨行去重

    当前行 = 起始行
    while 当前行 <= 结束行:
        行数据 = 获取行数据(当前行, 起始列, 结束列)

        # 遇到新标记或空行则停止
        if 行数据[0]以标记开头 or 行数据全空:
            if 当前行 > 起始行:
                break

        # 列去重：处理合并单元格（同一行重复内容）
        唯一值列表 = []
        已见列内容 = set()
        for 值 in 行数据[1:]:  # 跳过第一列的标记
            if 值 and 值 not in 已见列内容:
                唯一值列表.append(值)
                已见列内容.add(值)

        行内容 = " ".join(唯一值列表)

        # 行去重：防止多行重复（Excel 源文件可能包含重复行）
        if 行内容 and 行内容 not in 已见行内容集合:
            行内容列表.append(行内容)
            已见行内容集合.add(行内容)

        当前行 += 1

    最终文本 = "\n".join(行内容列表)
    return 最终文本
```

**去重说明**：
1. **列去重**：同一行内相同内容只保留一次（处理合并单元格）
2. **行去重**：不同行如果内容完全相同，只保留第一次出现（处理 Excel 源文件的重复行）

---

#### B. 奖励部分（RINK-）

**目标**：提取奖励项列表

##### 标记：`RINK-`

- **位置**：段落区块内任意行的第一列
- **格式**：`RINK-<奖励分组>`
  - 示例：`RINK-Top1`、`RINK-Top2-3`、`RINK-Top4-5`
- **内容特点**：
  - 奖励数据**不合并**，每列都是独立的数据
  - **不需要去重**

##### 列结构

```
| 列1(标记列) | 列2(名称) | 列3(图片路径) | 列4(描述) |
|-------------|-----------|---------------|-----------|
| RINK-Top1   | 头框男    | image.png     | 30天      |
|             | 勋章男    |               | 永久      |
|             | 称号男    |               | 永久      |
```

**列位置规则**：
- 列1：`RINK-` 标记（仅第一行）
- 列2：奖励名称
- 列3：奖励图片路径（可选）
- 列4：奖励描述

##### 解析逻辑

```python
# 伪代码
def collect_rewards(起始行, 标题):
    奖励列表 = []

    当前行 = 起始行
    while 当前行 <= 结束行:
        行数据 = 获取行数据(当前行, 起始列, 结束列)

        # 遇到新标记或空行则停止
        if 行数据[0]以标记开头 or 行数据全空:
            if 当前行 > 起始行:
                break

        # 按列位置提取数据
        名称 = 行数据[1] if len(行数据) > 1 else ""
        图片 = 行数据[2] if len(行数据) > 2 else ""
        描述 = 行数据[3] if len(行数据) > 3 else ""

        # 处理图片路径（复制/下载到指定目录，或读取嵌入图片）
        if 图片:
            图片路径 = 复制或下载图片(图片, 名称)
        else if 嵌入图片映射中有(当前行, 图片列):
            图片路径 = 嵌入图片映射[(当前行, 图片列)]
        else:
            图片路径 = 生成占位路径(名称)

        if 名称 or 描述 or 图片路径:
            奖励列表.append({
                "name": 名称,
                "image": 图片路径,
                "desc": 描述
            })

        当前行 += 1

    return 奖励列表
```

**图片处理**：
1. 如果列3有图片路径，复制/下载到 `IMG_OUT_DIR`
2. 如果列3为空，尝试从嵌入图片映射中获取（通过行列坐标）
3. 否则生成占位路径

---

## 标记说明

### 标记汇总表

| 标记       | 位置         | 用途               | 格式示例              | 备注                   |
|------------|--------------|--------------------|-----------------------|------------------------|
| `REGION-`  | 第一行       | 纵向分割页面       | `REGION-TW`           | 合并单元格，重复内容   |
| `TITLE-`   | 区域内第一列 | 横向分割段落区块   | `TITLE-活动规则`      | 到下一个TITLE或空行    |
| `RULES-`   | 区块内第一列 | 标记规则内容       | `RULES-规则` 或 `RULES-` | 后续列可能合并重复     |
| `RINK-`    | 区块内第一列 | 标记奖励内容       | `RINK-Top1`           | 数据不合并，不需去重   |

### 标记识别规则

```python
# 标记识别伪代码
def 识别标记(单元格内容):
    if 单元格内容.startswith("REGION-"):
        return "页面分割标记"
    elif 单元格内容.startswith("TITLE-"):
        return "段落标题标记"
    elif 单元格内容.startswith("RULES-"):
        return "规则内容标记"
    elif 单元格内容.startswith("RINK-"):
        return "奖励内容标记"
    else:
        return "普通内容"
```

---

## 数据结构

### 输出 JSON 格式

```json
{
  "pages": [
    {
      "region": "TW",
      "sections": [
        {
          "title": "规则",
          "content": "一、活动时间💗\n8.27 00:00-8.31 23:59\n二、活动玩法💗...",
          "rewards": []
        },
        {
          "title": "奖励-Top1",
          "content": "",
          "rewards": [
            {
              "name": "頭框男",
              "image": "/assets/image.png",
              "desc": "30天"
            }
          ]
        }
      ]
    }
  ]
}
```

### 数据类型定义（TypeScript）

```typescript
export type Reward = {
  name?: string;    // 奖励名称
  image?: string;   // 奖励图片路径
  desc?: string;    // 奖励描述
};

export type Section = {
  title?: string;      // 段落标题
  content?: string;    // 文本内容（规则部分）
  rewards?: Reward[];  // 奖励列表（奖励部分）
};

export type Page = {
  region?: string;      // 区域代码
  sections?: Section[]; // 段落区块列表
};

export type Data = {
  pages: Page[];  // 页面列表
};
```

---

## 常见问题

### Q1: 为什么规则内容会重复三遍？

**原因**：
1. **合并单元格导致列重复**：同一行的多个列是合并的，内容相同
2. **Excel 源文件包含重复行**：为了在 Excel 中占据更大显示区域，设计者可能在多行填入相同内容

**解决方案**：
- 实现**列去重**：同一行内相同内容只保留一次
- 实现**行去重**：不同行如果内容完全相同，只保留第一次出现

### Q2: 如何处理空行和空列？

**空行**：
- 在段落区块内，遇到空行表示当前内容结束
- 用于分隔不同的 `RULES-` 或 `RINK-` 块

**空列**：
- 在 `REGION-` 分割时，遇到空列表示当前页面结束
- 用于分隔不同的页面

### Q3: 图片是如何处理的？

**三种图片来源**：
1. **列3的图片路径**：复制/下载到指定目录
2. **嵌入图片**：从 Excel 的 `xl/media/` 中提取，并根据锚点坐标映射到单元格
3. **占位路径**：如果都没有，生成 `/assets/<奖励名称>.png` 作为占位

**处理流程**：
```python
if 列3有图片路径:
    图片路径 = 复制或下载(列3内容)
else if 嵌入图片映射有该单元格:
    图片路径 = 嵌入图片映射[(行, 列)]
else:
    图片路径 = f"/assets/{slugify(奖励名称)}.png"
```

### Q4: 合并单元格如何处理？

**处理策略**：
- 构建**合并单元格索引**（`merge_idx`）
- 读取单元格时，如果发现是合并单元格的一部分，返回合并区域左上角单元格的值
- 这样可以确保合并区域内的所有坐标都返回相同的值

```python
def get_value(ws, r, c, merge_idx):
    if (r, c) in merge_idx:
        r0, c0, _, _ = merge_idx[(r, c)]
        return ws.cell(r0, c0).value
    return ws.cell(r, c).value
```

### Q5: 相同标题的奖励分段如何合并？

**场景**：多个 `RINK-Top1` 块分散在不同位置

**解决方案**：
- 使用 `merge_reward_sections` 函数
- 按照首次出现顺序，将相同 `title` 的奖励分段的 `rewards` 列表合并
- 规则部分不合并

```python
def merge_reward_sections(sections):
    merged = []
    title_to_index = {}

    for s in sections:
        if s.get("rewards"):  # 奖励分段
            title = s.get("title", "")
            if title in title_to_index:
                # 合并到已存在的分段
                idx = title_to_index[title]
                merged[idx]["rewards"].extend(s["rewards"])
            else:
                # 新建分段
                title_to_index[title] = len(merged)
                merged.append(s)
        else:
            # 规则分段不合并
            merged.append(s)

    return merged
```

---

## 运行解析器

### API 方式（推荐）

**启动后端服务：**
```bash
python -m uvicorn backend.api.main:app --reload --host 127.0.0.1 --port 8000
```

**启动前端应用：**
```bash
cd web
pnpm dev
```

在浏览器中访问 `http://localhost:5173`，上传 Excel 文件即可解析。

### 输出格式

- **JSON 数据**：解析后的结构化数据通过 API 返回
- **图片数据**：存储在内存 blob 存储中，通过 `/media/{blob_hash}` 访问
- **终端输出**：显示解析的页数和图片数量

---

## 注意事项

1. **编码问题**：确保 Excel 文件使用 UTF-8 编码，避免中文乱码
2. **标记格式**：所有标记必须严格遵循格式（大小写敏感，包含 `-` 分隔符）
3. **合并单元格**：`REGION-` 和规则内容的列必须正确合并
4. **空行分隔**：使用空行明确分隔不同的内容块，避免解析错误
5. **列顺序**：奖励部分的列顺序必须固定（标记、名称、图片、描述）

---

## 相关文件

- **解析器**：`backend/services/excel_parser.py` - Python Excel 解析脚本
- **API 服务器**：`backend/api/main.py` - FastAPI 后端服务
- **图片提取**：`backend/services/image_extractor.py` - 图片提取器
- **前端渲染**：`web/src/renderer/canvas/PageCanvas.tsx` - Konva Canvas 渲染组件
- **类型定义**：`web/src/renderer/canvas/types.ts` - TypeScript 类型定义

---

## 更新日志

- **2025-01-XX**：初始版本，记录完整的 Excel 切割解析逻辑
- **列去重**：添加合并单元格去重逻辑
- **行去重**：添加跨行内容去重逻辑
